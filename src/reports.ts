import { FeedbackEntry, ReportSummary, DashboardStats } from './types';
import { D1Database } from './database';

export interface AIEnv {
  AI: any;
}

/**
 * Generate a daily or weekly report summary using AI
 */
export async function generateReportSummary(
  db: D1Database,
  ai: any,
  period: 'daily' | 'weekly'
): Promise<ReportSummary> {
  const days = period === 'daily' ? 1 : 7;
  const stats = await getDashboardStats(db, days);

  // Prepare context for AI summarization
  const context = `
Total Feedback: ${stats.totalFeedback}
Categories: ${JSON.stringify(stats.byCategory)}
Sentiment: ${JSON.stringify(stats.bySentiment)}
Top Sources: ${JSON.stringify(stats.bySource)}

Recent Feedback Samples:
${stats.recentFeedback.slice(0, 10).map(f => `- [${f.category}] ${f.content.substring(0, 100)}`).join('\n')}
`;

  try {
    const prompt = `As a product manager, analyze this ${period} feedback data and provide:
1. 3-5 key insights (what patterns do you notice?)
2. Top 3 categories that need attention
3. 2-3 actionable recommendations

${context}

Respond with ONLY a JSON object:
{
  "keyInsights": ["insight1", "insight2", ...],
  "topCategories": [{"category": "error", "count": 15}, ...],
  "recommendations": ["recommendation1", "recommendation2", ...]
}`;

    const response = await ai.run('@cf/meta/llama-3.1-8b-instruct', {
      messages: [
        {
          role: 'system',
          content: 'You are a product manager analyzing customer feedback. Always respond with valid JSON only.',
        },
        {
          role: 'user',
          content: prompt,
        },
      ],
    });

    const aiResult = JSON.parse(response.response || '{}');

    return {
      period,
      date: new Date().toISOString().split('T')[0],
      totalEntries: stats.totalFeedback,
      keyInsights: aiResult.keyInsights || ['No insights available'],
      topCategories: aiResult.topCategories || [],
      sentimentBreakdown: stats.bySentiment,
      recommendations: aiResult.recommendations || ['Continue monitoring feedback'],
    };
  } catch (error) {
    console.error('Report generation error:', error);
    // Fallback summary
    return generateFallbackSummary(stats, period);
  }
}

/**
 * Fallback summary when AI fails
 */
function generateFallbackSummary(stats: DashboardStats, period: 'daily' | 'weekly'): ReportSummary {
  const topCategories = Object.entries(stats.byCategory)
    .sort(([, a], [, b]) => b - a)
    .slice(0, 3)
    .map(([category, count]) => ({ category, count }));

  const insights: string[] = [];
  if (stats.totalFeedback > 50) {
    insights.push(`High volume of feedback received: ${stats.totalFeedback} entries`);
  }
  if (stats.bySentiment.negative > stats.bySentiment.positive) {
    insights.push('Negative sentiment outweighs positive feedback - needs attention');
  }
  if (topCategories.length > 0) {
    insights.push(`Most common category: ${topCategories[0].category} with ${topCategories[0].count} entries`);
  }

  return {
    period,
    date: new Date().toISOString().split('T')[0],
    totalEntries: stats.totalFeedback,
    keyInsights: insights.length > 0 ? insights : ['Review feedback patterns'],
    topCategories,
    sentimentBreakdown: stats.bySentiment,
    recommendations: [
      'Prioritize high-priority items',
      'Follow up on negative sentiment feedback',
      'Track category trends over time',
    ],
  };
}

async function getDashboardStats(db: D1Database, days: number): Promise<DashboardStats> {
  // Import here to avoid circular dependency
  const { getDashboardStats } = await import('./database');
  return getDashboardStats(db, days);
}

/**
 * Format report as email-friendly text
 */
export function formatReportAsEmail(report: ReportSummary): string {
  return `
${report.period.toUpperCase()} FEEDBACK REPORT - ${report.date}

Total Entries: ${report.totalEntries}

KEY INSIGHTS:
${report.keyInsights.map((insight, i) => `${i + 1}. ${insight}`).join('\n')}

TOP CATEGORIES:
${report.topCategories.map(cat => `- ${cat.category}: ${cat.count} entries`).join('\n')}

SENTIMENT BREAKDOWN:
${Object.entries(report.sentimentBreakdown).map(([sentiment, count]) => `- ${sentiment}: ${count}`).join('\n')}

RECOMMENDATIONS:
${report.recommendations.map((rec, i) => `${i + 1}. ${rec}`).join('\n')}

---
This report was automatically generated by the Feedback Aggregation System.
`;
}
